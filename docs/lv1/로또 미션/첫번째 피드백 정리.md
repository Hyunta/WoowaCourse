**안녕하세요 아서! 리뷰어 던입니다.**
**깔끔하게 잘 구현해주셨네요! 👍**
**가볍게 테스트 코드 위주로 코멘트 드렸습니다. 확인 부탁드리겠습니다!**

------

**따로 질문하신것에 답변드리겠습니다~**

1. **네! 말씀하신것처럼 "1"을 입력받는 테스트코드 부터 작성한 뒤에 테스트를 통과하도록 기능구현을 하면 됩니다. 나중에 테스트 코드가 깨질 수도 있을텐데요, 그때 테스트 코드를 수정하시면 됩니다! 처음부터 완성도 높은 테스트 코드를 작성하면 좋겠지만 크게 부담을 가지실 필요는 없어보입니다. 계속 추가/수정/삭제하면서 개발해나가시면 됩니다.**
2. **따로 정해진건 없고 비슷한 역할을 하는 클래스끼리 패키지로 묶으면 됩니다! 비슷한 역할을 한다고 판단하는 기준은 아서가 고민해볼 수 있을까요?**

---

**`private void isNumberFormat(String input)`**

**이름이 is + XXX 로 시작하는 메서드의 반환 타입은 boolean 값으로 지정하는게 일반적인 컨벤션입니다!**
**메서드명을 조금 더 적절한것으로 변경해볼 수 있을까요~?**

---

**Lotto 객체가 너무 많은 역할을 하고 있는 것 같은데요!**
**역할을 쪼개볼 수 있을까요?**

---

**예외가 발생하는 케이스 뿐만 아니라 정상적으로 처리된 로직도 검증해봐야 하지 않을까요?**

---

**입력된 당첨번호가 6개가 아닌경우의 처리로직도 원하는대로 실행되는지 검증해봐요!**
**로또숫자(ChoiceNumbers)끼리 겹치는 숫자가 몇개인지 구하는 로직도 검증해봐야겠네요!**

---

**로또결과를 계산하는 로직, 수익률 계산로직의 테스트가 빠져있네요!**

---

```java
Assertions.assertThat(lottoResult.sumOfPrize()).isEqualTo(1555000);
```

**예상결과 값을 하드코딩하지 않고 작성해볼 수 있을까요?**

---

**LottoRank의 로직들도 테스트 해보도록 해요!**

테스트를 하던 중 @CsvSource를 이용해서 한번에 테스트를 했는데 `LottoRank` 를 리팩터링을 하다 문제가 발생했습니다.`LottoRank.RANK_SECOND` 형식에서 `LottoRank.SECOND` 와 같이 변경을 하니까 테스트가 실패했습니다.

```java
@CsvSource(value = { "6:false:FIRST","5:true:SECOND"}, delimiter = ':')
```

이런 경우에 테스트를 분리해서 각 등수마다 테스트를 따로 만드는게 나을까요?

---

**InputView, OutputView를 인스턴스화해서 사용하는 이유를 알 수 있을까요?**
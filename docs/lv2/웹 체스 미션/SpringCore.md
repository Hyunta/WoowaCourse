### Q&A

1. 스프링 애노테이션이 동작하는 내부 구현 코드는 어떻게 확인할 수 있나요?

   간단한 코드일 경우에는 내부 구현을 통해 로직을 확인할 수 있지만, 스프링의 경우는 내용이 너무 방대해서 아무런 정보없이 찾는 것은 미로찾기 같을 수 있다. 굉장히 많은 시간이 걸리고 원하는 결과를 모를 수도 있다.

   - 미로를 위에서 바라보면 알 수 있다.
   - 지도를 사용한다. -> 이런 방향으로 코드를 추적해보면 찾을 수 있겠다.

   MVC 동작원리를 알아보자 -> Dispatcher Servlet / Handler Mapping / View Resolver 객체가 어떤 역할을 하는지 확인해보자

   **하지만, 지금 몰라도 상관없다. 레벨2에서는 실습 경험을 많이 쌓아보자**



---



## 테스트로 배우는 Spring Core

### 배경 지식 강의

<문장 2가지>

1. 객체는 **의존 관계**를 가짐, **스프링**이 이 관계를 관리함

(모든 관계를 관리하는 것은 아님)

2. **스프링**은 개발자를 대신해서 **객체들을 생성하고 관리**하는 일을 한다.

(모든 객체를 관리하는 것은 아님)



<질문 2가지>

1. 스프링이 관리할 객체를 **어떻게** 지정할까?
2. **어떤 객체**를 스프링이 관리하게 해야할까?



---

ChessService가 ChessDao를 어떻게 의존하게 만들지?

직접 의존성을 관리하려고 하니 중복이 생기고, 복잡하다...그냥 누가 알아서 관리를 해줬으면 좋겠다 -> 스프링 컨테이너: 내가 관리해줄게

Container? 컨테이너? : 뭔가를 담는 것 / 스프링 컨테이너 - 스프링 빈들을 담는 것



스프링이 객체를 관리하게 하려면 Configuration Metadata를 넘겨준다/ 이를 기반으로 빈을 생성한다.



우리는 이미 컨테이너에 빈을 등록해보고 의존성 주입도 해봤다.

클래스 위에 애노테이션을 붙였더니, 스프링 컨테이너가 관리할 빈이 되었다.

의존성은 생성자를 만들었더니 주입이 되더라...

```
<컨테이너 설정 방법>

1. XML
2. Annotation-based configuration
3. Java-based configuration

## Spring-Learning-Test 기반으로 학습하자
```



#### 빈 등록 방법

@ComponentScan 과 @Component를 이용하여 등록하는 방법을 소개

애노테이션은 결국 @Component이다



#### 의존성 주입 방법(without 스프링 컨테이너)

1. 생성자 주입:

생성자에 @Autowired를 작성해야 하는데, 생성자가 하나일 경우는 생략해도된다.

2. 수정자 주입:

setter에 @Autowired를 붙이면 작동한다.

**Q. 필드 주입은 왜 안좋나요?** 

1. 순환 참조 에러가 날 수 있다.
2. null 값이 들어오지 않도록 방지할 수 있다.



빈과 컴포넌트의 차이점


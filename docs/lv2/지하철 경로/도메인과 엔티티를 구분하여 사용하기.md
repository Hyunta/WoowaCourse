토니가 도메인과 엔티티를 구분하면서 느낀점에 대해서 공유해달라고 하셨다. 나도 이 구조에 대해서 고민을 해봤었지만, 구구의 피드백을 듣고 반영하려다 말았는데 이번에 페어였던 엘리가 구현을 해놨길래 간접적으로 체험할 수 있었다.



>도메인과 엔티티를 분리하고 레포지토리에서 변환을 담당하는군요..!
>
>이렇게 구성을 잡고 개발하셨을 때 아서가 느낀점이 궁금해요 😎



먼저 제가 직접 구현한게 아니라 페어였던 엘리의 코드를 사용해서 이 부분이 추가된거라 모호할수도 있습니다.

실은 이 주제에 대해서 요즘 크루들과 많이 이야기하고 있습니다. 제가 느낀 결론에 대해서 미리 말해드리자면 지금 당장은 불편하다 입니다.

`비지니스 로직에 엔티티를 가져와서 사용하는게 아니라 도메인을 써야하지 않을까?`

주어진 역할에 책임을 다하고 협력하는 자율적인 객체를 만드는 것이 객체 지향의 핵심이라고 생각하고, 이렇게 개발을 했을 때 유지보수가 편해지고, 테스트하기가 쉽고, 읽기 쉬운 코드가 작성된다는 점에 동의합니다. 하지만 가끔은 너무 이상적인게 아닌가 라고 생각합니다.

이번 프로젝트에서도 마찬가지로  엔티티와 도메인을 분리하여 철저히 비지니스 로직을 격리시키는게 더 객체지향적이라는 점에 동의합니다. 하지만 DB에 저장을 하는 로직을 바라봤을 때 너무 일이 복잡해집니다. 구간(section)을 저장할 때 일어나는 일은 아래와 같습니다.

```markdown
1. 노선Id와 추가할 상행선 Id, 하행선 Id, 거리를 요청받는다.
2. sectionDao에서 노선Id를 갖고 있는 모든 구간을 불러온다.
3. 불러온 구간 정보를 이용해 section 객체를 생성한다.
4. stationDao에 접근하여 station을 생성해서 section에 넣어준다.
5. section들을 모아 sections를 만든다.
6. 요청받은 상행성 Id, 하행성 Id로 section 객체를 만든다.
7. sections에 추가할 수 있는지 검증후 sections를 변경한다.
8. 기존 sections를 삭제한다.
9. 새로운 sections를 추가한다.
```

제가 느낄 때 4번,6번,8번,9번이 도메인과 엔티티를 분리하면서 발생한 일이라고 생각합니다. 만약 분리하지 않았더라면 id를 통해서 동일한 로직을 수행하고 id를 이용해서 기존 구간의 정보를 update 하는 방식으로 처리할 수 있어서 간편하지 않을까 했습니다. 뭔가 크루들 사이에서 객체 지향이 옳고 JPA에서 이렇게 하니까 비지니스 로직은 도메인으로 처리해야지 하는 흐름이 있는 것 같습니다. 하지만 저는 객체 지향이 항상 옳을 순 없고 JPA가 그렇게 하기때문이라는 근거는 부실하다고 생각합니다.  필요에 따라서 일부는 객체를 이용하지 않고 구현을 하는 것도 괜찮지 않을까? 라고 생각합니다. 예를 들어 역을 저장할 때 중복을 방지하려고 모든 station을 객체로 불러와 객체끼리 비교하는 방법 보다는, db에 unique를 지정하고 저장 했을 때 반환되는 exception을 이용하는 것이 더 낫다고 생각합니다.

분명히 서비스가 커지게 된다면 각 계층별로 철저히 격리시키기 위해서 노력해야한다는 점에 동의하고, 규모에 따라서 좋은 설계는 바뀔 수 있지 않을까라는 생각을 하고 있습니다. 혹시 작성한 내용중에 잘못됐거나 제가 잘못알고 있는 내용이 있다면 알려주세요!

토니의 생각도 공유해주셨으면 좋겠습니다!
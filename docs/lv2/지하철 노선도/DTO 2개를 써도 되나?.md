레이어드 아키텍처 관련 고민중인데요,[이 포스팅]([http://tech.pick-git.com/%EB%B3%80%EA%B2%BD%EC%97%90-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%84%A4%EA%B3%84,-%EC%9A%B0%EB%A6%AC%EB%8A%94-2%EA%B0%80%EC%A7%80-%EC%A2%85%EB%A5%98%EC%9D%98-DTO%EB%A5%BC-%EC%93%B4%EB%8B%A4/](http://tech.pick-git.com/변경에-유연한-설계,-우리는-2가지-종류의-DTO를-쓴다/))이 너무 많은 도움이 되었습니다!매 레이어마다 의존성을 단방향으로 가져가기 위해컨트롤러에서 받은 Dto를 서비스에서 사용되는 Dto로 변환해서메시지를 보내는 것으로 이해했는데요,컨트롤러 Dto를 그대로 서비스로 보내지 않고 서비스 용 Dto로 변환해서 메시지를 보낼 경우



\- 컨트롤러가 비대해진다

\- 개발자가 파악하기 어려워진다

\- 지속적이고 확정적인 비용이 발생하는 것에 비해 어차피 API 스펙 변경시 하위 레이어 Dto도 어차피 변경되어야 한다.



라는 단점이 떠올라서요,혹시 변경에 유연한 구조를 위해 위와 같은 포스팅에서 설명하신 구조로 만드신 것으로 이해하고 있는데,그로 인한 실익은 크지 않았을 것 같다 라는 느낌이 듭니다!혹시 이 부분에 대해 경험담을 나눠주실 수 있을까요?!



---



가장 먼저 말씀드리고 싶은것은, 제가 말씀드리는 건 정답이 아니라 제 생각과 현업 경험을 통해 나온 하나의 “의견“일 뿐인걸 항상 인지해 주셨으면 감사하겠습니다.결론부터 말씀드리면, 우아한형제들의 표준 아키텍쳐는 위와같이 dto를 2개로 나누어서 사용하고 있습니다 (개인적으로는 우형 표준 아키텍쳐가 썩 마음에 드는 편은 아니지만). 이렇게 구성된 이유에는 여러가지 이유가 있는데요. 그 중 저에게 가장 다가왔던 이유는 `도메인 로직의 재사용` 이라고 말씀드릴 수 있을 것 같아요.먼저 질문 주신 내용들에 대해서 답변을 드리고 시작하겠습니다.

- **컨트롤러가 비대해진다**
- 컨트롤러가 비대해진다는 것은 mapping 로직이 들어감으로 발생하는 문제를 말씀해 주시는 것 같아요. 사실 이런 부분은 DTO Assembler 패턴을 통해 해결할 수 있습니다. (`엔터프라이즈 애플리케이션 아키텍처 패턴` 에서 관련 내용을 찾을 수 있습니다.) 일종의 Mapper 클래스를 만들고 mapping로직을 모두 해당 클래스 안으로 몰아넣는 식으로 구성되게 됩니다. 그러면 컨트롤러에서는 변환로직이 많아야 2줄이면 끝나면서 컨트롤러 코드가 비대해지지 않게 유지할 수 있게 됩니다.
- 만일 이런 매핑 로직 자체가 들어가는걸 비대하다고 느끼신거라면, 전혀 그렇지 않다고 말씀드릴 수 있을 것 같습니다. 컨트롤러의 역할인 “요청을 받고, 응답을 제공한다” 의 관점에서 보게 된다면, mapping로직은 응답을 제공하기 위한 데이터 가공의 로직이며, 도메인 로직으로 보기 어렵습니다. 이러한 로직은 컨트롤러의 책임이 분명하며 이 코드가 존재하는게 이상하다고 생각되지 않는게 저의 생각입니다.
- **개발자가 파악하기 어려워진다**
- 로버트 마틴의 클린아키택쳐를 읽어보면 이런 말이 나옵니다 `페러다임은 개발자의 자유를 제한하며 만들어진다“. 함수형 페러다임, 객체지향 페러다임 등, 모든 개발의 철학은 개발자의 자유도를 깍아먹으면서 생겨난다는 이야기 이지요. 그 말은, 모든 설계원칙은 규율과 규칙이 있고 이를 지키면서 코드를 작성함으로써 그 아키텍쳐가 완성되는 것 입니다.
- 위 말을 왜 했는가 하니, `개발자가 파악하기 어려워진다` 라는 의견은 사실 좋은 의견이 아니라고 생각하기 때문입니다. 모든 학문이 그렇듯, 어느 사실을 인지하고 있는가, 없는가에 따라서 똑같은 글을 보더라도 사람마다 다르게 받아들여집니다. 우테코에서 배우는 객체지향 프로그래밍, 객체에게 책임을 할당하고, 협업을 만들어내며 도메인 로직을 서비스가 아닌 도메인 객체에 밀어넣는 설계법 (이하 객체지향 설계). 우리가 봤을때는 당연하다고 여겨지는 설계법이고 그게 맞다고 생각하지만, 실제로 많은 개발자분들은 그러한 설계법을 이해하지 못합니다. 서비스에 비즈니스 로직이 존재하는걸 당연하다고 생각하는 분들도 많이 계십니다. 즉, 그러한 철학을 가진 개발자 분들의 시각으로 봤을때는 우리가 작성하는 객체지향 설계 기반의 소스코드는 `파악하기 어려운 코드` 가 될 것 입니다.
- dto를 두번 사용하는것도 개발자의 자유도를 깍아먹는 일종의 설계 패턴이라 볼 수 있습니다(대분류로 따지면 계층형 아키텍쳐 패러다임으로 볼 수 있겠네요). 즉, 개발자가 파악하기 쉽다 어렵다는 dto를 계층에 걸쳐 2번 사용하자라는 설계원칙을 모두가 인지하고 이해하는가에 따른 문제인 것이지 일반화되서 말할 수 있는 문제는 아니라고 생각합니다.
- **지속적이고 확정적인 비용이 발생하는 것에 비해 어차피 API 스펙 변경시 하위 레이어 Dto도 어차피 변경되어야 한다.**
- 이와 관련해서는 뒤에서 서술하겠지만, controller와 service의 dto가 언제나 같은 필드를 가진다는 생각 안에서 발생한 의문이라고 생각합니다. 만일 서비스에서 반환하는 dto와 controller의 dto가 다른 데이터 구조를 가진다면 어떤점에서 이점이 있을지 생각해볼 수 있을 것 같습니다.

**도메인 로직의 재사용**위에서 제가 dto를 2번 사용하는것에 대해 `도메인 로직의 재사용` 이 하나의 이유가 될 수 있다고 말씀드렸습니다. 어떤 상황을 말씀드리는가 하니. 우리는 비즈니스적 문제를 해결하기 위해서 수많은 API를 필요로 합니다. 그리고 그 API를 하나하나 만드는 것은 모든 개발자들의 리소스를 할애하는 행위입니다.만일 서로 다른 데이터를 반환해야하는 API 생성 요청이 2개 들어왔다고 가정해 봅시다.

```
### A API
{
  A : data
}

### B API
{
  B : data
}
```

위와같이 A api와 B api를 만들어야 하고 이를 개발하기 시작합니다. 그런데 개발을 하다보니 A와 B api가 같은 비즈니스 로직을 필요로 하는 것을 발견했습니다.이 경우 어떻게 개발하시겠나요? 코드의 중복을 만들어 낼껀가요?저같은 경우는 이런 경우 동일한 service를 호출하도록 합니다. 그리고 service의 반환은 아래와 같이 하도록 구성합니다.

```
{
  A : data,
  B : data
}
```

이제 A api와 B api는 동일한 비즈니스 로직(service)를 호출하고 각자 자신에게 필요한 데이터면 가져다가 view에게 응답합니다. 즉, 도메인 로직의 재사용이 발생했습니다.그 다음, 또 새로운 요구사항이 왔고, 이번에는 데이터 C를 요청합니다. 그리고 이 데이터 C또한 동일한 service를 통해 얻을 수 있다고 가정합니다.그러면 위 service로직의 반환 dto 구조를 아래와 같이 변경할 수 있습니다.

```
{
  A : data,
  B : data,
  C : data
}
```

그러면 이번에도 C API를 구성하는 controller에서 C data만 추출하며 응답을 만들어내 수 있겠죠.
여기서 중요한 점은 우리가 C라는 데이터를 필요로 하는 새로운 요구사항이 왔고, 이를 해결했음에도 A API와 B API를 구성하는 Controller코드를 건들 필요가 없었다는 겁니다. 즉 일족의 OCP를 만족했다고도 볼 수 있겠네요(원칙적으론 다른 이야기지만).
DTO를 2개 계층으로 나누는게 변경과 확장에 유리한 설계가 되는 이유가 조금은 납득이 되셨을지요. 다시 한번 강조드리지만 제가 말씀드린게 “정답“이 아닌 “의견“이라는걸 인지해 주셨으면 좋겠습니다.사실 조금 더 디테일하게 설명하기 위해서는 도메인로직, 비즈니스 로직의 차이점과 철학에 대해 이야기 드리고 싶지만, 제이슨이 혼낼것 같아서 여기까지만 하도록 하겠습니다
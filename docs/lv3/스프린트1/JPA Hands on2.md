# 📖 JPA Hands-on Part 2

# 들어가기 전에

- 객체는 파스칼 표기법을 따른다.
  - `Line`, `Station`, `Member`, `Favorite`, `LineStation`
- 테이블은 스네이크 표기법을 따른다.
  - `line`, `station`, `member`, `favorite`, `line_station`

# 연관 관계

- 엔티티들은 대부분 다른 엔티티와 연관 관계가 있다.
- 객체는 참조(주소)를 사용해서 관계를 맺고 테이블은 외래 키를 사용해서 관계를 맺는다.

## 핵심 키워드

- 방향: 단방향, 양방향이 있다.방향은 객체 관계에만 존재하고 테이블 관계는 항상 양방향이다.
- 다중성: 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)
- 연관 관계의 주인: 객체를 양방향 연관 관계로 만들면 연관 관계의 주인을 정해야 한다.

## 다대일, 일대다 연관 관계

- 역과 노선이 있다.
- 지하철역은 하나의 노선에만 소속될 수 있다.
  - **환승역은 고려하지 않는다.**
- **지하철역과 노선은 다대일(N:1) 관계다.**
- **노선과 지하철역은 일대다(1:N) 관계다.**

```java
class Line {
    Long id;
    String name;
}

class Station {
    Long id;
    String name;
}
```

## 다대일 단방향 연관 관계

```java
@Entity
@Table(name = "line")
public class Line {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    ...

}
@Entity
@Table(name = "station")
public class Station {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;
    
    @ManyToOne // (1)
    @JoinColumn(name = "line_id") // (2)
    private Line line; // (3)
    
    public void setLine(final Line line) { // (4)
        this.line = line;
    }
    
    ...

}
```

1. ```
   @ManyToOne
   ```

   - 다대일(N:1) 관계라는 매핑 정보

2. ```
   @JoinColumn
   ```

   - 컬럼 이름과 외래 키가 참조할 컬럼을 직접 지정하지 않는다면 굳이 선언하지 않아도 된다.

3. 지하철역 객체는

    

   ```
   line
   ```

    

   필드로 노선 객체와 연관 관계를 맺는다.

   - **`Station` -> `Line`: 가능**
   - **`Line` -> `Station`: 불가능**
   - `station` -> `line`: 가능
   - `line` -> `station`: 가능
   - **지하철역과 노선은 단방향 관계다.**

4. 연관 관계를 설정하는 메서드

## 실습

- 콘솔에 실행되는 테이블 생성 DDL을 출력해 보자.

```sql
create table line (
    id bigint generated by default as identity,
    name varchar(255) not null,
    primary key (id)
)

create table station (
    id bigint generated by default as identity,
    name varchar(255) not null,
    line_id bigint,
    primary key (id)
)

alter table station 
    add constraint FKklalypfiiahjy57wtapf4w92 
    foreign key (line_id) 
    references line
```

## 실습

- 연관 관계를 설정한 후 저장에 대한 테스트를 해 보자.

```java
@Test
void saveWithLine() {
    Station expected = new Station("잠실역");
    expected.setLine(new Line("2호선"));
    Station actual = stations.save(expected);
    stations.flush(); // transaction commit
}
insert 
into
    station
    (id, line_id, name) 
values
    (null, null, '잠실역')
```



JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.

```java
@Test
void saveWithLine() {
    Station expected = new Station("잠실역");
    expected.setLine(lines.save(new Line("2호선")));
    Station actual = stations.save(expected);
    stations.flush(); // transaction commit
}
insert 
into
    line
    (id, name) 
values
    (null, '2호선')
    
insert 
into
    station
    (id, line_id, name) 
values
    (null, 1, '잠실역')
```

## 실습

- 조회에 대한 테스트를 해 보자.
- `data.sql`

```sql
INSERT INTO line (id, name) VALUES (1, '3호선')
INSERT INTO station (id, line_id, name) VALUES (1, 1, '교대역')
@Test
void findByNameWithLine() {
    Station actual = stations.findByName("교대역");
    assertThat(actual).isNotNull();
    assertThat(actual.getLine().getName()).isEqualTo("3호선");
}
select
    station0_.id as id1_1_,
    station0_.line_id as line_id3_1_,
    station0_.name as name2_1_ 
from
    station station0_ 
where
    station0_.name='교대역'
    
select
    line0_.id as id1_0_0_,
    line0_.name as name2_0_0_ 
from
    line line0_ 
where
    line0_.id=1
```

## 실습

- 수정에 대한 테스트를 해 보자.

```java
@Test
void updateWithLine() {
    Station expected = stations.findByName("교대역");
    expected.setLine(lines.save(new Line("2호선")));
    stations.flush(); // transaction commit
}
update
    station 
set
    line_id=2,
    name='교대역'
where
    id=1
```

## 실습

- 연관 관계 제거에 대한 테스트를 해 보자.

```java
@Test
void removeLine() {
    Station expected = stations.findByName("교대역");
    expected.setLine(null);
    stations.flush(); // transaction commit
}
update
    station 
set
    line_id=null,
    name='교대역'
where
    id=1
```



노선을 삭제하려면 기존에 있던 연관 관계를 먼저 제거하고 삭제해야 한다.

## 양방향 연관 관계

- 반대 방향으로 객체 그래프 탐색이 가능하다.

```java
@Entity
@Table(name = "line")
public class Line {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;

    @OneToMany(mappedBy = "line") // (1)
    private List<Station> stations = new ArrayList<>(); // (2)
    
    ...

}
```

1. ```
   @OneToMany
   ```

   - 일대다(1:N) 관계라는 매핑 정보
   - `mappedBy` 속성은 연관 관계 주인의 필드 이름

2. 노선 객체는

    

   ```
   stations
   ```

    

   필드로 지하철역 객체와 연관 관계를 맺는다.

   - **`Station` -> `Line`: 가능**
   - **`Line` -> `Station`: 가능**
   - `station` -> `line`: 가능
   - `line` -> `station`: 가능
   - **지하철역과 노선은 양방향 관계다.**

## 실습

- 조회에 대한 테스트를 해 보자.

```java
@Test
void findById() {
    Line line = lines.findByName("3호선");
    assertThat(line.getStations()).hasSize(1);
}
select
    line0_.id as id1_0_,
    line0_.name as name2_0_ 
from
    line line0_ 
where
    line0_.name='3호선'

select
    stations0_.line_id as line_id3_1_0_,
    stations0_.id as id1_1_0_,
    stations0_.id as id1_1_1_,
    stations0_.line_id as line_id3_1_1_,
    stations0_.name as name2_1_1_ 
from
    station stations0_ 
where
    stations0_.line_id=1
```

## 연관 관계의 주인

- 엄밀히 이야기하면 객체에는 양방향 연관 관계라는 것이 없다.
- 서로 다른 단방향 연관 관계 2개를 양방향인 것처럼 보이게 할 뿐이다.
  - **지하철역과 노선은 다대일(N:1) 관계다.**
  - **노선과 지하철역은 일대다(1:N) 관계다.**
- **연관 관계의 주인만이 데이터베이스 연관 관계와 매핑되고 외래 키를 등록, 수정, 삭제할 수 있다.**
- **주인이 아닌 쪽은 읽기만 할 수 있다.**



연관 관계의 주인을 정한다는 것은 외래 키 관리자를 선택하는 것이다. 비즈니스 중요도로 접근하면 안 된다.



데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래 키를 가진다.

## 실습

- 저장에 대한 테스트를 해 보자.

```java
@Test
void save() {
    Line expected = new Line("2호선");
    expected.addStation(new Station("잠실역"));
    lines.save(expected);
    lines.flush(); // transaction commit
}
insert 
into
    line
    (id, name) 
values
    (null, '2호선')
@Test
void save() {
    Line expected = new Line("2호선");
    expected.addStation(stations.save(new Station("잠실역")));
    lines.save(expected);
    lines.flush(); // transaction commit
}
insert 
into
    station
    (id, line_id, name) 
values
    (null, null, '잠실역')

insert 
into
    line
    (id, name) 
values
    (null, '2호선')
```



연관 관계의 주인이 아닌 곳에 입력된 값은 외래 키에 영향을 주지 않는다.

## 연관 관계 편의 메서드

- 양방향 연관 관계는 결국 양쪽 다 신경 써야 한다.

```java
station.setLine(line);
line.addStation(station);
```

- 양방향 관계에서 두 코드는 하나인 것처럼 사용하는 것이 안전하다.
- 한 번에 양방향 관계를 설정하는 메서드를 **연관 관계 편의 메서드**라 한다.

```java
public void setLine(Line line) {
    this.line = line;
    line.getStations().add(this);
}
public void addStation(Station station) {
    stations.add(station);
    station.setLine(this);
}
```



양방향 매핑 시에는 무한 루프에 빠지지 않게 조심해야 한다.

## 연관 관계 편의 메서드 작성 시 주의 사항

```java
station.setLine(line1);
station.setLine(line2);
boolean contains = line1.getStations().contains(station); // true
public void setLine(Line line) {
    if (Objects.nonNull(this.line) {
        this.line.getStations().remove(this);
    }
    this.line = line;
    line.getStations().add(this);
}
```

## 일대다 단방향 연관 관계

```java
@Entity
public class Favorite {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    protected Favorite() {
    }
}
@Entity
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToMany // (1)
    @JoinColumn(name = "member_id") // (2)
    private List<Favorite> favorites = new ArrayList<>(); // (3)

    ...

}
```

1. ```
   @OneToMany
   ```

   - 일대다(1:N) 관계라는 매핑 정보

2. ```
   @JoinColumn
   ```

   - **`favorite`의 외래 키**

3. 사용자 객체는

    

   ```
   favorites
   ```

    

   필드로 지하철역 객체와 연관 관계를 맺는다.

   - **`Member` -> `Favorite`: 가능**
   - **`Favorite` -> `Member`: 불가능**
   - `member` -> `favorite`: 가능
   - `favorite` -> `member`: 가능
   - **사용자와 즐겨찾기는 단방향 관계다.**

## 실습

- 콘솔에 실행되는 테이블 생성 DDL을 출력해 보자.

```sql
create table favorite (
    id bigint generated by default as identity,
    member_id bigint,
    primary key (id)
)

create table member (
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
)

alter table favorite 
   add constraint FK5w3q9ljpthkixo71hetx3ired 
   foreign key (member_id) 
   references member
```

## 실습

- 저장에 대한 테스트를 해 보자.

```java
@Test
void save() {
    Member expected = new Member("jason");
    expected.addFavorite(favorites.save(new Favorite()));
    Member actual = members.save(expected);
    members.flush(); // transaction commit
}
insert 
into
    favorite
    (id) 
values
    (null)

insert 
into
    member
    (id, name) 
values
    (null, 'jason')

update
    favorite 
set
    member_id=1 
where
    id=1
```

## 일대다 단방향 매핑의 단점

- 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다.
- 연관 관계 처리를 위한 UPDATE SQL을 추가로 실행해야 한다.
- **일대다 단방향 매핑보다는 다대일 양방향 매핑을 권장한다.**

## 일대일 연관 관계

- 일대일 관계는 그 반대도 일대일 관계다.

- 일대일 관계는 주 테이블이나 대상 테이블 둘 중 어느 곳이나 외래 키를 가질 수 있기 때문에

   

  외래 키를 어느 곳에 두어야 하는지 고민을 해야 한다.

  - `station`이 주 테이블이고 `line_station`이 대상 테이블이라고 가정한다.

```java
class Station {
    Long id;
    String name;
    LineStation lineStation;
}

class LineStation {
    Long id;
}
```

## 주 테이블에 외래 키

- 주 테이블이 외래 키를 가지고 있으므로 주 테이블만 확인해도 대상 테이블과 연관 관계가 있는지 알 수 있다.
  - **`Station` -> `LineStation`: 가능**

### 단방향 연관 관계

```java
@Entity
@Table(name = "line_station")
public class LineStation {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "line_id")
    private Line line;
    
    ...

}
@Entity
@Table(name = "station")
public class Station {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false)
    private String name;

    @OneToOne // (1)
    @JoinColumn(name = "line_station_id") // (2)
    private LineStation lineStation; // (3)
    
    ...

}
```

1. ```
   @OneToOne
   ```

   - 일대일(1:1) 관계라는 매핑 정보

2. ```
   @JoinColumn
   ```

   - 컬럼 이름과 외래 키가 참조할 컬럼을 직접 지정하지 않는다면 굳이 선언하지 않아도 된다.

3. 지하철역 객체는

    

   ```
   lineStation
   ```

    

   필드로 노선의 지하철역 객체와 연관 관계를 맺는다.

   - **`Station` -> `LineStation`: 가능**
   - **`LineStation` -> `Station`: 불가능**
   - `station` -> `line_station`: 가능
   - `liline_stationne` -> `station`: 가능

## 실습

- 콘솔에 실행되는 테이블 생성 DDL을 출력해 보자.

```sql
create table line_station (
    id bigint generated by default as identity,
    line_id bigint,
    primary key (id)
)

create table station (
    id bigint generated by default as identity,
    name varchar(255) not null,
    line_station_id bigint,
    primary key (id)
)

alter table station 
   add constraint FKtkxivxas996j9c54ngcd0bby2 
   foreign key (line_station_id) 
   references line_station
```

## 실습

- 저장에 대한 테스트를 해 보자.

```java
@Test
void saveWithLineStation() {
    LineStation lineStation = lineStations.save(new LineStation());
    stations.save(new Station("잠실역", lineStation));
}
insert 
into
    line_station
    (id, line_id) 
values
    (null, 1)

insert 
into
    station
    (id, line_station_id, name) 
values
    (null, 1, '잠실역')
```

### 양방향 연관 관계

```java
@Entity
@Table(name = "line_station")
public class LineStation {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "line_id")
    private Line line;
    
    @OneToOne(mappedBy = "lineStation") // (1)
    private Station station; // (2)
    
    ...

}
```

1. ```
   @OneToOne
   ```

   - 일대일(1:1) 관계라는 매핑 정보
   - `mappedBy` 속성은 연관 관계 주인의 필드 이름

2. 노선의 지하철역 객체는

    

   ```
   station
   ```

    

   필드로 지하철역 객체와 연관 관계를 맺는다.

   - **`Station` -> `LineStation`: 가능**
   - **`LineStation` -> `Station`: 가능**
   - `station` -> `line_station`: 가능
   - `line_station` -> `station`: 가능

## 대상 테이블에 외래 키

- 테이블 관계를 일대일에서 일대다로 변경할 때 테이블 구조를 그대로 유지할 수 있다.
  - **환승역을 고려해 본다.**

### 단방향 연관 관계

- 이런 모양으로 매핑할 수 있는 방법이 없다.
  - **`Station` -> `LineStation`: 불가능**
  - **`LineStation` -> `Station`: 불가능**

### 양방향 연관 관계

```java
@Entity
@Table(name = "line_station")
public class LineStation {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "line_id")
    private Line line;
    
    @OneToOne
    @JoinColumn(name = "station_id")
    private Station station;
    
    ...

}
@Entity
@Table(name = "station")
public class Station {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false)
    private String name;

    @OneToOne(mappedBy = "station")
    private LineStation lineStation;
    
    ...

}
```

## 실습

- 콘솔에 실행되는 테이블 생성 DDL을 출력해 보자.

```sql
create table line_station (
    id bigint generated by default as identity,
    line_id bigint,
    station_id bigint,
    primary key (id)
)

create table station (
    id bigint generated by default as identity,
    name varchar(255) not null,
    primary key (id)
)

alter table line_station 
    add constraint FK78y8i0a0kum6n7s2qss4wi6i9 
    foreign key (station_id) 
    references station
```

## 다대다 연관 관계

- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.
- 보통 다대다 관계를 일대다, 다대일 관계로 풀어내는 연결 테이블을 사용한다.
- **연결 테이블에 필드가 추가되면 더는 사용할 수 없다.**

# 더 하고 싶은 말

- 지연 로딩
- CASCADE
- 고아 객체
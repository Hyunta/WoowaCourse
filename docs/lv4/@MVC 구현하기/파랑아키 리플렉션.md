## 리플렉션 이란?

스프링은 어떻게 실행 시점에 빈을 주입할 수 있나요?

JPA Entity는 왜 기본 생성자를 가져야 하나요?

실체가 아닌 반사. 반영된 이미지를 통해 무언가를 하는 것을 리플렉션이라 한다.





## 리플렉션이 제공하는 기능들

Class는 실행중인 자바 어플리케이션의 클래스와 인터페이스의 정보를 가진 클래스

Class 객체는 JVM에 의해 자동으로 생성되고, public 생성자가 없다.



Class를 가져오는 방법

1. {클래스타입}.class
2. {인스턴스}.getClass()
3. Class.forName("{전체 도메인 네임}")



getMethods - 상위 클래스와 인터페이스에서 상속한 메서드를 포함하여 public을 모두 가져온다.

getDeclaredMethods - 접근 제어자에 관계없이 직접 클래스에 선언한 메서드를 가져온다.



**생성자**

생성자의 파라미터로 구분하여 클래스에 선언된 생성자를 가져올 수 있다.

생성자의 접근제어자가 public이 아닌경우 setAccessible을 true하면 생성가능하다



**필드 정보 조회**

필드의 접근제어자, 타입, 네임, 값 등의 정보를 조회할 수 있다.

 private 필드의 값도 변경할 수 있다.



**메서드 정보 조회**

메서드의 접근제어자, 리턴타입, 네임, 파리미터 타입 등의 정보를 가져올 수 있다.

private 메서드도 호출할 수 있다.



### 리플렉션이 사용되는 곳

왜 쓰는가? 프레임워크나 라이브러리에서 많이 쓴다.

컴파일 시점엔 객체의 타입을 모르기 때문에 동적으로 해결하기 위해 사용한다.

JPA, Jackson, Mockito, Junit 등등



Request Dto, Jpa Entity 등 

객체의 기본생성자가 필요한 이유?

**기본 생성자로 객체를 생성하고 필드를 통해 값을 넣어주는 것이 가장 간단한 방법이기 때문이다!**

기본 생성자를 사용할 경우 모든 경우의 수들을 고려하지 않아도 된다.



**애노테이션으로 작동하는것도 리플렉션 때문이다**

1. 리플렉션을 통해 클래스나 메서드 파라미터 정보를 가져온다.
2. getAnnotation, getDeclaredAnnotaion등을 통해서 설정한다.



단점1. 일반 메서드 호출보다 성능이 떨어진다.

- 컴파일 시점이 아니라 런타임 시점에 클래스를 분석한다 -> JVM 최적화 불가능

단점2. 컴파일 시점에서 타입 체크 기능을 사용할 수 없다.

단점4. 내부를 노출해서 추상화를 파괴한다.






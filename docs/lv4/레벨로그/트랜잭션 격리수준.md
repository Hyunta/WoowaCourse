**Lock**은 동시성을 제어하기 위한 기능

**트랜잭션**은 데이터의 정합성을 보장하기 위한 기능

Lock은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.

격리 수준이라는 것은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨을 의미한다.



### READ UNCOMMITTED

각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보여진다. Dirty Read 현상은 데이터가 나타났다가 사라졌다 하는 현상을 초래하므로 애플리케이션 개발자와 사용자를 혼란스럽게 만들 것이다. MySQL을 사용한다면 최소한 READ COMMITED 이상의 격리 수준을 사용할 것을 권장한다.



### READ COMMITTED

오라클 DBMS에서 기본적으로 사용되는 격리 수준. Dirty Read가 발생하지 않는다. COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.

READ COMMITED 격리 수준에서는 어떤 트랜잭션에서 변경한 내용이 커밋되기 전까지는 다른 트랜잭션에서 그러한 변경 내역을 조회할 수 없다.

NON-REPEATABLE READ 라는 부정합 문제가 있다.



### REPEATABLE READ

MySQL의 InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준이다. 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 Undo 공간에 백업해두고 실제 레코드 값을 변경한다.

사용자가 BEGIN으로 트랜잭션을 시작하고 장시간 동안 트랜잭션을 종료하지 않으면 Undo 영역이 무한정 커질 수도 있다.



### SERIALIZABLE

한 트랜잭션이 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다. 가장 엄격한 격리 수준이다. 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다.



## 트랜잭션 부정합 문제 3가지

### 1.   Dirty Read

어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상



### 2. NON-REPEATABLE READ

REPEATABLE READ가 불가능하다. 사용자 B가 하나의 트랜잭션 내에서 SELECT를 두번 진행할때 그 사이에 사용자 A가 정보를 수정하고 COMMIT하면 두번의 결과가 다르다. 일반적인 웹 프로그램에서는 문제가 되지 않지만, 금전적인 처리와 연결되면 문제가 될 수도 있다.



### 3. PHANTOM READ

SELECT ... FOR UPDATE 쿼리를 두 번 보낼 때 중간에 데이터가 변경되면 레코드가 보였다가 안 보였다가 하는 현상이 나타난다.





